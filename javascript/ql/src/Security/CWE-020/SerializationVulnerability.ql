/**
 * @kind path-problem
 */

import javascript
import DataFlow::PathGraph

predicate replaceOne(DataFlow::SourceNode input, DataFlow::Node output, string old, string new) {
  exists(DataFlow::ObjectLiteralNode map |
    map.hasPropertyWrite(old, any(DataFlow::Node esc | esc.getStringValue() = new)) and
    map.getAPropertyRead().flowsTo(output) and
    input.flowsToExpr(output.(DataFlow::PropRead).getPropertyNameExpr())
  )
  or
  exists(EqualityTest eq, ConditionGuardNode cond |
    eq.hasOperands(any(Expr e | input.flowsToExpr(e)), any(Expr e | e.getStringValue() = old)) and
    cond.getTest() = eq and
    cond.getOutcome() = eq.getPolarity() and
    cond.dominates(output.getBasicBlock()) and
    new = output.getStringValue()
  )
}

predicate replaceAll(DataFlow::SourceNode input, DataFlow::Node output, string old, string new) {
  exists(Variable idx, DataFlow::CallNode char, Variable buf, AssignAddExpr cat, VarAccess res |
    char = input.getAMethodCall("charAt") and
    char.getArgument(0).asExpr() = idx.getAnAccess() and
    exists(RelationalComparison cmp |
      cmp.getLesserOperand() = idx.getAnAccess() and
      input.getAPropertyRead("length").flowsToExpr(cmp.getGreaterOperand())
    ) and
    replaceOne(char, cat.getRhs().flow(), old, new) and
    cat.getLhs() = buf.getAnAccess() and
    res = buf.getAnAccess() and
    not res.isLValue() and
    output = res.flow()
  )
  or
  exists(StringReplaceCall repl |
    repl.isGlobal() and
    input = repl.getReceiver().getALocalSource() and
    repl.flowsTo(output) and
    repl.replaces(old, new)
  )
  or
  exists(DataFlow::InvokeNode invk, DataFlow::FunctionNode callee, int i |
    callee.getFunction() = invk.getACallee() and
    input.flowsTo(invk.getArgument(i)) and
    replaceAll(callee.getParameter(i), callee.getAReturn(), old, new) and
    invk.flowsTo(output)
  )
}

predicate sanitizer(DataFlow::FunctionNode f, DataFlow::ParameterNode parm) {
  parm = f.getAParameter() and
  exists(DataFlow::Node out |
    replaceAll(parm, out, "<", "\\u003C") and
    TaintTracking::localTaintStep*(out, f.getAReturn())
  )
}

predicate sourceSinkPair(DataFlow::FunctionNode f, DataFlow::Node source, DataFlow::Node sink) {
  sanitizer(f, source) and
  sink = f.getAReturn()
}

class Configuration extends TaintTracking::Configuration {
  Configuration() { this = "Configuration" }

  override predicate isSource(DataFlow::Node nd) { sourceSinkPair(_, nd, _) }

  override predicate isSink(DataFlow::Node nd) { sourceSinkPair(_, _, nd) }

  override predicate isAdditionalTaintStep(DataFlow::Node pred, DataFlow::Node succ) {
    exists(ForInStmt fis, SsaExplicitDefinition ssa |
      pred = fis.getIterationDomain().flow() and
      ssa.getDef() = fis.getIteratorExpr() and
      succ = DataFlow::ssaDefinitionNode(ssa)
    )
  }

  override predicate isSanitizer(DataFlow::Node nd) {
    nd.(DataFlow::MethodCallNode).getMethodName() = "replace"
    or
    nd.(DataFlow::PropRead).getPropertyName() = "flags"
  }
}

from Configuration cfg, DataFlow::FunctionNode f, DataFlow::PathNode source, DataFlow::PathNode sink
where
  sourceSinkPair(f, source.getNode(), sink.getNode()) and
  cfg.hasFlowPath(source, sink) and
  sink.isBalanced()
select source, source, sink, "Inconsistent sanitization."
